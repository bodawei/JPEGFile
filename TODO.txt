* Test JunkSegment
* Test DataSegment
* Comment should copde with utf8 and > 1024 bytes
* Can DQT have more than 1K of data?  if so, deal with it
* Can we explain the other structures as well as Dht?
* Architecture changes
  * Deal with imperfect data better
	* EOF or length too long: ?
	* length too short  (can't happen)
	* length and internal data say different things
	* internal data has invalid values (we could allow)
  * Reconsider how markers are done (instance or static method)
  * readFromFile/Stream methods maybe should be static also?  Certainly, they need to be able to return different classes based on the type.
	* Maybe this should be doing the java serialization scheme?

* In JpegParser
** what should isValid do?
** Create a subtype of DataInput which keeps track of what byte one is at (so can be put in error, and perhaps reported usefully in jpeg file?
* Exif or other metadata added
* Finish JpegParser
* Do a jpeg scanner? (e.g. find me this one segment without reading everything in so much)

----
Resolve what to do about markers

Basic thrust is to use loki's suggestion: can ask a factory method for an instance.
Best of all ask the factory "can you do this marker code?"

Resolve this issue:
1) Do the factory with a static
	- no inheritance system to promise that one will be there
	- have to do reflection

2) Do it as an instance method
	- have to instantiate an instance just to create more
	- aesthetics seem odd (ask an instance for an instance)


	@Override
	public SegmentBase createInstance(int subType) throws IllegalArgumentException {
		return new EoiSegment(subType);
	}
	
	/**
	 * Construct
	 */
	public EoiSegment(int subType) {
		if (subType != EoiSegment.MARKER) {
			throw new IllegalArgumentException("Only " + EoiSegment.MARKER +
					" may be passed as a subtype");
		}


	@Test
	public void getGetInstance() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		Class<?> c = EoiSegment.class;
		Class<?>[] params = new Class<?>[] { Integer.class };
		Method m = c.getMethod("createInstance", params);
		EoiSegment s = (EoiSegment) m.invoke(null, new Integer(5));
		
		assertTrue(s instanceof EoiSegment);
	}

Arguably, readFrom...() should be a factory/class method, not an instance one.

